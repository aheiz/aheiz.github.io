{"version":3,"sources":["src/lib/nativescript-webview-interface.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sBAAsB;AAC/C;AACA;AACA;AACA;AACA,sC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD","file":"scripts.js","sourcesContent":["/**\r\n * WebViewInterface class to handle communication between webView and Android/iOS.\r\n */\r\nvar NSWebViewinterface = (function () {\r\n    function NSWebViewinterface() {\r\n        \r\n        /**\r\n         * Mapping of native eventName and its handler in webView\r\n         */\r\n        this.eventListenerMap = {};\r\n        \r\n        /**\r\n         * Mapping of JS Call responseId and result for iOS\r\n         */\r\n        this._iosResponseMap = {};\r\n        \r\n        /**\r\n         * Counter of iOS JS Call responseId\r\n         */\r\n        this._iosCntResponseId = 0;\r\n    }\r\n    \r\n    /**\r\n     * Handles events/commands emitted by android/ios. This function is called from nativescript.\r\n     * @param   {string}    eventName - Native event/command name\r\n     * @param   {data}      data - Payload for the event/command\r\n     */\r\n    NSWebViewinterface.prototype._onNativeEvent = function (eventName, data) {\r\n        var lstEvtListeners = this.eventListenerMap[eventName] || [];\r\n        for (var _i = 0; _i < lstEvtListeners.length; _i++) {\r\n            var listener = lstEvtListeners[_i];\r\n            var retnVal = listener && listener(data);\r\n            // if any handler return false, not executing any further handlers for that event.\r\n            if (retnVal === false) {\r\n                break;\r\n            }\r\n        }\r\n    };\r\n    \r\n   /**\r\n     * Handles JS function calls by android/ios. This function is called from nativescript.\r\n     * Result value of JS function call can be promise or any other data.\r\n     * @param   {number}    reqId - Internal communication id\r\n     * @param   {string}    functionName - Function to be executed in webView\r\n     * @param   {any[]}     args  \r\n     */\r\n    NSWebViewinterface.prototype._callJSFunction = function (reqId, functionName, args) {\r\n        var _this = this;\r\n        var resolvedFn = _this._getResolvedFunction(functionName);\r\n        if(resolvedFn){\r\n            var retnVal = resolvedFn.apply(window, args);\r\n            if (retnVal && retnVal.then) {\r\n                retnVal.then(function (value) {\r\n                    _this._sendJSCallResponse(reqId, value);\r\n                }, function(error){\r\n                    _this._sendJSCallResponse(reqId, error, true);\r\n                });\r\n            }\r\n            else {\r\n                this._sendJSCallResponse(reqId, retnVal);\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Resolves a function, if the function to be executed is in deep object chain.\r\n     * e.g If we want to execute a function 'parent.child.child.fn' from native app, \r\n     * this function will extract fn from the object chain. \r\n     * We can do it by using eval also, but as there is a way, why to invite unknown security risks? \r\n     * \r\n     */\r\n    NSWebViewinterface.prototype._getResolvedFunction = function(functionName){\r\n        if(functionName && (functionName = functionName.trim()).length){\r\n            functionName = functionName.indexOf('window.') === 0 ? functionName.replace('window.', '') : functionName;\r\n            var arrFnPath = functionName.split('.');\r\n            var fn = window;\r\n            for(var i =0; i < arrFnPath.length; i++){\r\n                if(!fn[arrFnPath[i]]){\r\n                    fn = null;\r\n                    break;\r\n                }\r\n                fn = fn[arrFnPath[i]]; \r\n            }\r\n            return fn;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Returns JS Call response by emitting internal _jsCallRespone event\r\n     */\r\n    NSWebViewinterface.prototype._sendJSCallResponse = function (reqId, response, isError) {\r\n        var oResponse = {\r\n            reqId: reqId,\r\n            response: response || null,\r\n            isError: !!isError\r\n        };\r\n        this.emit('_jsCallResponse', oResponse);\r\n    };\r\n    \r\n    /**\r\n     * Creates temporary iFrame element to load custom url, for sending handshake message \r\n     * to iOS which is necessary to initiate data transfer from webView to iOS\r\n     */\r\n    NSWebViewinterface.prototype._createIFrame = function (src) {\r\n        var rootElm = document.documentElement;\r\n        var newFrameElm = document.createElement(\"IFRAME\");\r\n        newFrameElm.setAttribute(\"src\", src);\r\n        rootElm.appendChild(newFrameElm);\r\n        return newFrameElm;\r\n    };\r\n    \r\n    /**\r\n     * Sends handshaking signal to iOS using custom url, for sending event payload or JS Call response.\r\n     * As iOS do not allow to send any data from webView. Here we are sending data in two steps.\r\n     * 1. Send handshake signal, by loading custom url in iFrame with metadata (eventName, unique responseId)\r\n     * 2. On intercept of this request, iOS calls _getIOSResponse with the responseId to fetch the data.\r\n     */\r\n    NSWebViewinterface.prototype._emitEventToIOS = function (eventName, data) {\r\n        this._iosResponseMap[++this._iosCntResponseId] = data;\r\n        var metadata = { eventName: eventName, resId: this._iosCntResponseId };\r\n        var url = 'js2ios:' + JSON.stringify(metadata);\r\n        var iFrame = this._createIFrame(url);\r\n        iFrame.parentNode.removeChild(iFrame);\r\n    };\r\n    \r\n    /**\r\n     * Returns data to iOS. This function is called from iOS.\r\n     */\r\n    NSWebViewinterface.prototype._getIOSResponse = function (resId) {\r\n        var response = this._iosResponseMap[resId];\r\n        delete this._iosResponseMap[resId];\r\n        return response;\r\n    };\r\n    \r\n    /**\r\n     * Calls native android function to emit event and payload to android\r\n     */\r\n    NSWebViewinterface.prototype._emitEventToAndroid = function (eventName, data) {\r\n        window.androidWebViewInterface.handleEventFromWebView(eventName, data);\r\n    };\r\n    \r\n    /**\r\n     * Registers handlers for android/ios event/command\r\n     */\r\n    NSWebViewinterface.prototype.on = function (eventName, callback) {\r\n        var lstListeners = this.eventListenerMap[eventName] || (this.eventListenerMap[eventName] = []);\r\n        lstListeners.push(callback);\r\n    };\r\n    \r\n    /**\r\n     * Emits event to android/ios\r\n     */\r\n    NSWebViewinterface.prototype.emit = function (eventName, data) {\r\n        var strData = typeof data === 'object' ? JSON.stringify(data) : data;\r\n        if (window.androidWebViewInterface) {\r\n            this._emitEventToAndroid(eventName, strData);\r\n        }\r\n        else {\r\n            this._emitEventToIOS(eventName, strData);\r\n        }\r\n    };\r\n    return NSWebViewinterface;\r\n})();\r\nwindow.nsWebViewInterface = new NSWebViewinterface();\r\n"],"sourceRoot":"webpack:///"}